{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE TypeApplications #-}
-- |

module Test.Consensus.TestBlock.Tests (tests) where

import qualified Data.List.NonEmpty as NE
import           Ouroboros.Consensus.Block
import qualified Ouroboros.Network.AnchoredFragment as AF
import           Test.Consensus.BlockTree
import           Test.Consensus.Genesis.Setup.GenChains
import           Test.QuickCheck
import           Test.Tasty
import           Test.Tasty.QuickCheck
import           Test.Util.TestBlock (TestBlock, TestHash (unTestHash))

tests :: TestTree
tests = testGroup "Test.Util.TestBlock"
    [ testProperty "TestHash ~ pathFromHash" $ prop_pathFromHash
    ]

-- | The chain path representation stored in a 'TestHash' is equivalent to
-- the one computed by 'pathFromHash', i.e. they might differ
-- on non-zero elements (corresponding to forking nodes) only.
-- This is so because fork numbers are meant to distinguish (or tag) forks,
-- not sort them.
-- To document a quirk of the implementation, we test that if the 'BlockTree'
-- generated by 'genChains' has only one alternative chain (fork),
-- then both path representations are the same.
prop_pathFromHash :: Property
prop_pathFromHash = property $ do
  n <- choose (1,5)
  GenesisTest{gtBlockTree} <- genChains @TestBlock (pure n)
  let tipHashes = [ either AF.anchorToHash (BlockHash . blockHash) . AF.head $ branches
                  | branches <- btTrunk gtBlockTree : (fmap btbSuffix . btBranches $ gtBlockTree)
                  ]
      newPathsFromHash = fmap (pathOnChain gtBlockTree) tipHashes
      storedPathsInHash =
        fmap
          -- | The 'TestHash' stores the path in reverse order
          -- i.e. head is newest.
          ( \case BlockHash hash -> reverse . NE.toList . unTestHash $ hash
                  GenesisHash -> mempty
          )
          tipHashes
  pure $ case n of
    1 -> all (uncurry (==)) $ zip newPathsFromHash storedPathsInHash
    _ -> all (uncurry matchingZeros) $ zip newPathsFromHash storedPathsInHash

-- | 'True' if and only if the number lists have the same length and match zero-wise.
matchingZeros :: (Eq a, Num a) => [a] -> [a] -> Bool
matchingZeros xs ys = fmap (== 0) xs == fmap (== 0) ys
